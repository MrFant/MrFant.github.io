# 十六进制转八进制之大数问题的处理

> **问题描述**
> 　　给定n个十六进制正整数，输出它们对应的八进制数。
>
> **输入格式**
> 　　输入的第一行为一个正整数n （1<=n<=10）。
> 　　接下来n行，每行一个由0~9、大写字母A~F组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。
>
> **输出格式**
> 　　输出n行，每行为输入对应的八进制正整数。
>
> 　　**【注意**】
> 　　输入的十六进制数不会有前导0，比如012A。
> 　　输出的八进制数也不能有前导0。
>
> **样例输入**
> 　　2
> 　　39
> 　　123ABC
>
> **样例输出**
> 　　71
> 　　4435274
>
> 　　**【提示**】
> 　　先将十六进制数转换成某进制数，再由某进制数转换成八进制。



这道题目的关键在于处理的数据位数，题目要求转换的十六进制数长度不超过十万位，十万位的十六进制数据是不可能由常规的数据类型来存储，只能存储为字符串类型。把输入存储为字符串类型后，就可以对其进行转换了，转换有以下几种思路：

一、将字符串中的每一位十六进制数转换为二进制数，再3位3位得将二进制数组合成八进制输出，这也是题目hints的思路，网上大多数都是以此为解。

二、第二个思路就是我自己所想的了，剑走偏锋，另辟蹊径。主要是：由于一位十六进制数的二进制为是四位，而八进制的二进制为是三位，所以3个十六进制数可以转换为4个八进制数。所以可以对输入的十六进制字符串3位3位得进行处理，转换为int类型的值，再在输出时利用规则漏洞`cout<<oct<<value;` 直接输出这3位十六进制数的八进制表示。这种方法算是一种“凑输出”的“作弊”手段吧，但是这毕竟是做题，而且算法结果确实能够提高效率，故不失为一种好方法。

### 算法细节：

前缀数的处理：

由于是对输入字符串的每3位进行处理，但是字符串位数不一定是3的倍数，所以需对字符串前面几个前缀数字进行特殊处理。

容易忽略的一点就是，在第二种方法中对字符串后面的每次三位处理的过程中由于是直接输出3位十六进制数的（先转换成int型）八进制表示，所以有可能出现漏输出0位的情况（如把0x1FF输出成“777”，正确的应该输出“0777”）为避免漏位，故需对该值进行分情况处理。我就是在这里摔了跤，忽略了细节。。。。

思路一源码：

```c++
#include <iostream>
#include <string>
using namespace std;

int main()
{
    int n;
    cin>>n;
    for(int k=1;k<=n;k++)
    {
        string s1,s2;//s1为输入的原始的十六进制串，s2为转化成的二进制串
        cin>>s1;
        s2="";//初始化
        for(int i=0;i<s1.length();i++)//遍历，字符串上加上每一位
        {
            switch(s1[i])
            {
                case '0':s2+="0000";break;
                case '1':s2+="0001";break;
                case '2':s2+="0010";break;
                case '3':s2+="0011";break;
                case '4':s2+="0100";break;
                case '5':s2+="0101";break;
                case '6':s2+="0110";break;
                case '7':s2+="0111";break;
                case '8':s2+="1000";break;
                case '9':s2+="1001";break;
                case 'A':s2+="1010";break;
                case 'B':s2+="1011";break;
                case 'C':s2+="1100";break;
                case 'D':s2+="1101";break;
                case 'E':s2+="1110";break;
                case 'F':s2+="1111";break;
                default:break;
            }
        }
        int len=s2.length();

        if(len%3==1)//三个二进制为一位八进制，二进制串前面补0，确保二进制串的长度为3的倍数
            s2="00"+s2;
        else if(len%3==2)
            s2="0"+s2;
        int flag=0;//对前缀数字的处理
        for(int i=0;i<s2.length();i+=3)
        {
            int num=4*(s2[i]-'0')+2*(s2[i+1]-'0')+(s2[i+2]-'0');
            if(num)
                flag=1;//忽略前导0
            if(flag)
                cout<<num;
        }
        cout<<endl;
    }
    return 0;
}
```



这是网上一博主的源码，比较具有代表性。



思路二源码：

```c++
#include <iostream>
//#include <string>
using namespace std;
int str2int(char c){
    if ((int)c>='A')
        return (int)c-'A'+10;   //for A==10
    else return (int)c-'0';
}

int main(){
    //int str2int(char c);
    int n;
    cin>>n;
    string str;
    unsigned long strLength;
    int value;
    unsigned long prex;
    for (int i=0;i<n;i++){
        cin>>str;
        strLength=str.length();
        //value=0;
        prex=strLength%3;
        //以下是对前面几个数字对特殊处理
        if (prex==2){
            value=str2int(str[0])*16+str2int(str[1]);
            cout<<oct<<value;
        }
        else if(prex==1){
            value=str2int(str[0]);
            cout<<oct<<value;
        }

        for (;prex<strLength;prex+=3){
            //每3位处理
            value=str2int(str[prex])*16*16+str2int(str[prex+1])*16+str2int(str[prex+2]);
            if (prex != 0) {
                //补0以防止漏位
                // 0777的十进制表示为512，0077为 63 ，0007为 7
                // 故分别补0
                if (value<512&&value>63)
                    cout<<0;
                if (value <=63&&value>7)
                    cout<<"00";
                if (value<=7)
                    cout << "000";

            }
            cout<<oct<<value;
        }
        cout<<endl;

    }
    return 0;
}

```

两种方法输入系统的结果如下，方法二为第一条。

![对比](https://ws3.sinaimg.cn/large/006tKfTcgy1flt25pxwe7j30vc0680to.jpg)



可见方法二在代码长度，cpu使用时间和内存使用上都比方法一优越。

但是这只是一个浅显的对比，两种算法都没有优化，在此仅提供一种思路，没有优劣之分。。。。。。。



## 反思

1、细节之处一定要多注意。

2、对蓝桥杯的输入输出的判罚机制有了更多了解，原来可以不用把输入全部输进去再输出结果，如本方法中的源码一般输入一条，输出一条也是可以的。

3、对本题方法一中的str.Length() 的 i为int型有点疑惑，因为之前总结出的蓝桥杯的编译系统为8位或16位，int类型应该存储不下十万这么大的数才对，但此处证明可以，有些疑惑，先挖个坑，到时候填。。。。。。。